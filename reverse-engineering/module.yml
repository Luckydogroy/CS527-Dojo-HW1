name: Reverse Engineering
description: ""
challenges:
- id: level-1-0
  name: level1.0
  description: Reverse engineer this challenge to find the correct license key.
- id: level-1-1
  name: level1.1
  description: Reverse engineer this challenge to find the correct license key.
- id: level-2-0
  name: level2.0
  description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
    before being compared to the correct key.
- id: level-2-1
  name: level2.1
  description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
    before being compared to the correct key.
- id: level-3-0
  name: level3.0
  description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
    before being compared to the correct key.
- id: level-3-1
  name: level3.1
  description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
    before being compared to the correct key.
- id: level-4-0
  name: level4.0
  description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
    before being compared to the correct key.
- id: level-4-1
  name: level4.1
  description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
    before being compared to the correct key.
- id: level-5-0
  name: level5.0
  description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
    before being compared to the correct key.
- id: level-5-1
  name: level5.1
  description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
    before being compared to the correct key.
- id: level-6-0
  name: level6.0
  description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
    before being compared to the correct key.
- id: level-6-1
  name: level6.1
  description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
    before being compared to the correct key.
- id: level-7-0
  name: level7.0
  description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
    before being compared to the correct key.
- id: level-7-1
  name: level7.1
  description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
    before being compared to the correct key.
- id: level-8-0
  name: level8.0
  description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
    before being compared to the correct key.
- id: level-8-1
  name: level8.1
  description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
    before being compared to the correct key.
- id: level-9-0
  name: level9.0
  description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
    before being compared to the correct key. This challenge allows you to patch 5 bytes in the binary.
- id: level-9-1
  name: level9.1
  description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
    before being compared to the correct key. This challenge allows you to patch 5 bytes in the binary.
- id: level-10-0
  name: level10.0
  description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
    before being compared to the correct key. This challenge allows you to patch 1 byte in the binary.
- id: level-10-1
  name: level10.1
  description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
    before being compared to the correct key. This challenge allows you to patch 1 byte in the binary.
- id: level-11-0
  name: level11.0
  description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
    before being compared to the correct key. This challenge allows you to patch 2 bytes in the binary, but performs an
    integrity check afterwards.
- id: level-11-1
  name: level11.1
  description: Reverse engineer this challenge to find the correct license key, but your input will be modified somehow
    before being compared to the correct key. This challenge allows you to patch 2 bytes in the binary, but performs an
    integrity check afterwards.
- id: level-12-0
  name: level12.0
  description: |-
    We're about to dive into reverse engineering obfuscated code!
    To better prepare you for the journey ahead, this challenge is a very straightforward crackme, but using slightly different code, memory layout, and input format.
    We will progressively obfuscate this in future levels, but this level should be a freebie!
- id: level-12-1
  name: level12.1
  description: |-
    We're about to dive into reverse engineering obfuscated code!
    To better prepare you for the journey ahead, this challenge is a very straightforward crackme, but using slightly different code, memory layout, and input format.
    We will progressively obfuscate this in future levels, but this level should be a freebie!
- id: level-13-0
  name: level13.0
  description: |-
    Let's dive into reverse engineering obfuscated code!
    This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
    If you are clever, you won't need to reverse _too_ much VM code.
- id: level-13-1
  name: level13.1
  description: |-
    Let's dive into reverse engineering obfuscated code!
    This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
    If you are clever, you won't need to reverse _too_ much VM code.
- id: level-14-0
  name: level14.0
  description: |-
    Let's dive into reverse engineering obfuscated code!
    This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
    If you are clever, you won't need to reverse _too_ much VM code.
- id: level-14-1
  name: level14.1
  description: |-
    Let's dive into reverse engineering obfuscated code!
    This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
    If you are clever, you won't need to reverse _too_ much VM code.
- id: level-15-0
  name: level15.0
  description: |-
    Let's dive into reverse engineering obfuscated code!
    This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
    If you are clever, you won't need to reverse _too_ much VM code.
- id: level-15-1
  name: level15.1
  description: |-
    Let's dive into reverse engineering obfuscated code!
    This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
    If you are clever, you won't need to reverse _too_ much VM code.
- id: level-16-0
  name: level16.0
  description: |-
    Let's continue deeper in reverse engineering obfuscated code!
    This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
- id: level-16-1
  name: level16.1
  description: |-
    Let's continue deeper inreverse engineering obfuscated code!
    This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
- id: level-17-0
  name: level17.0
  description: "This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand\
    \ how to get the flag!"
- id: level-17-1
  name: level17.1
  description: "This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand\
    \ how to get the flag!"
- id: level-18-0
  name: level18.0
  description: "This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand\
    \ how to get the flag!"
- id: level-18-1
  name: level18.1
  description: "This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand\
    \ how to get the flag!"
- id: level-19-0
  name: level19.0
  description: |-
    This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
    This is a full end-to-end obfuscated challenge, like you might see in real-world obfuscated code!
- id: level-19-1
  name: level19.1
  description: |-
    This challenge is using VM-based obfuscation: reverse engineer the custom emulator and architecture to understand how to get the flag!
    This is a full end-to-end obfuscated challenge, like you might see in real-world obfuscated code!
- id: level-20-0
  name: level20.0
  description: 'Reverse engineer this custom emulator and architecture to understand how to get the flag! '
- id: level-20-1
  name: level20.1
  description: 'Reverse engineer this custom emulator and architecture to understand how to get the flag! '
- id: level-21-0
  name: level21.0
  description: Reverse engineer this custom emulator and architecture, and write your own custom shellcode to get the flag.
- id: level-21-1
  name: level21.1
  description: Reverse engineer this custom emulator and architecture, and write your own custom shellcode to get the flag.
- id: level-22-0
  name: level22.0
  description: |-
    Reverse engineer this custom emulator and architecture, and write your own custom shellcode to get the flag, with a twist.
    This is the final boss.
    Are you a true Yan-head?
- id: level-22-1
  name: level22.1
  description: |-
    Reverse engineer this custom emulator and architecture, and write your own custom shellcode to get the flag, with a twist.
    This is the final boss.
    Are you a true Yan-head?
resources:
- name: "Reverse Engineering: Introduction"
  type: lecture
  video: ClVocVk1c5g
  playlist: PL-ymxv0nOtqrGVyPIpJeostmi7zW5JS5l
  slides: 1hw_STBTJh4xqMv4TZAPRqt2rYIEAXXaCQlaBetxUufU
- name: "Reverse Engineering: Functions and Frames"
  type: lecture
  video: 3IdeyjrMBA4
  playlist: PL-ymxv0nOtqrGVyPIpJeostmi7zW5JS5l
  slides: 125gIw6rNKvwa-1DO6j3HTWbWtr2q3xD2coTCb0CgmAw
- name: "Reverse Engineering: Data Access"
  type: lecture
  video: AtVprTb5xBs
  playlist: PL-ymxv0nOtqrGVyPIpJeostmi7zW5JS5l
  slides: 154CQfQtpleaAQv9xNI1FVosbXc_18VZvXVpcs9Ljzzo
- name: "Reverse Engineering: Static Tools"
  type: lecture
  video: ls4Eoew6aSY
  playlist: PL-ymxv0nOtqrGVyPIpJeostmi7zW5JS5l
  slides: 1GcRLX3-cD9eLweEixmBPfawY7viOQWApG7E_HFfqHQQ
- name: "Reverse Engineering: Dynamic Tools"
  type: lecture
  video: HcBordv7aWU
  playlist: PL-ymxv0nOtqrGVyPIpJeostmi7zW5JS5l
  slides: 13yzjaRTIlloV8Lg5fcQN2ZYXooVqizLgHVby1ltYeWY
- name: "Reverse Engineering: Real-world Applications"
  type: lecture
  video: 2pqvHSy11JE
  playlist: PL-ymxv0nOtqrGVyPIpJeostmi7zW5JS5l
  slides: 1HWiy6OzvPO8YhgTPOsALobh9LagZsJ3Jsx7DJFLAKn4
- name: Other Resources
  type: markdown
  content: |
    There are many resources related to reverse engineering around the internet.

    - A good place to start is a series of walkthroughs of several hacking challenges by ASU's own Adam Doupe on his [YouTube channel](https://www.youtube.com/watch?v=qGt-0OOAFcM&list=PLK06XT3hFPziMAZj8QuoqC8iVaEbrlZWh).
    - A comprehensive revese engineering [tutorial series](https://github.com/mytechnotalent/Reverse-Engineering).
- name: Useful Tools
  type: markdown
  content: |
    As mentioned in the slides, there are a number of useful tools for this assignment!
    Here is a (non-exhaustive) list:

    * `gdb` will let you run and inspect the state of these programs.
      Please check out the Debugging Refresher module.
      We have also provided a quick briefer here.
      Some useful gdb concepts:
       * Know the difference between `step instruction` (`si`) and `next instruction` (`ni`).
         It boils down to the fact that `si` will follow jumps, and `ni` will step over jumps.
         This means that if you use `si`, you will quickly find yourself crawling through libc code, which is insane and unnecessary.
       * You can use `x/i $rip` to disassemble the next instruction that will be executed.
         You can call `display/i $rip` to make the next instruction display every time gdb prompts you for input.
         You can also do `x/2i` and `display/2i` to print two (or other quantities of) instructions.
       * The `disas` command will disassemble the current function that you are looking at.
       * gdb can be scripted!
         Look up conditional breakpoints and scriptable breakpoints in the gdb manual.
       * Modern binaries are _position independent_, meaning that they can be loaded anywhere in memory when they run.
         GDB will load them at the offset `0x555555554000`.
         This means that if objdump is telling you that main starts at some address like, `0x100`, the address when debugging with GDB will be `0x555555554100`
    * `strings` will list printable strings in the file.
      This is useful for looking for constant strings that the program checks for (such as file names and so on) in the course of getting input.
      Keep in mind that the options for string include a minimum size that it will print.
    * Don't forget about pwntools! You will need to interact heavily with these programs. Do it right (with pwntools).
    * `rappel` is a nice tool to help you figure out what certain instructions do.
    * Tools for reverse engineering actual binaries:
       * IDA, accessible via the Desktop in the dojo, is the industry standard of reverse-engineering tools.
       * Ghidra, also accessible via the Desktop in the dojo, is an open source direct competitor to IDA that is used and loved by many.
       * angr-management, also accessible via the Desktop in the dojo, is an open source up-and-coming reversing tool with some advanced functionality.
       * [Binary Ninja Cloud](https://cloud.binary.ninja), accessible separately through your web browser, is a free binary reverse engineering tool.
       * In a pinch, `objdump -d -M intel the_binary` will disassemble the binary you want to look at.
         `-M intel`, in that command, makes objdump give you nice and readable Intel assembly syntax.

